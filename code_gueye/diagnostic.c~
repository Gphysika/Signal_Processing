/*PROGRAM diagnostic by sound/vibration analysis
  NAME:
    diagnostic

  AUTHOR:
    AMADOU GUEYE (AG), Année pré-doctorale, amadou.gueye@univ-psl.fr
 
  PURPOSE:
 
 
  CALLING SEQUENCE: CALL coordonnees
   
  DESCRIPTION:
 
  ARGUMENTS:
 
 
 
  RETURN VALUE:
 
    0 if everything worked fine
  
 OUTPUT:
 
 
  MODIFICATION HISTORY:
    change into fprintf(dat,"%lf\n", data[2*i]);
    int k=0;
    change for (i=0; i<taille; i++) line 378 : for (i=0; i<taille; i++){fprintf(dat,"%lf\n", data
    [i])} is chnged to for (k=0; k<i; k++){fprintf(dat,"%lf\n", data[2*k])};
     changed theta=isign*(6.28318530717959/mmax) by intrduce 2*pi;
    Commented void four1() (28/03/2018)

  Compilation: 
    gcc -c -ansi -Wall -Wextra diagnostic.c -lm
    gcc diagnostic.o diagnostic.o -o
    

  Execution:
    ./diagnostic


On distingue 2 parties dans un fichier WAVE : l’entête et la partie DATA. L’entête mesure 56 octets et contient les informations sur le format utilisé pour encoder le son (nombre d’octets par point échantillonné, nombre de canaux, fréquence d’échantillonnage, longueur du fichier…).
La partie DATA commence à l’octet 57 et contient toutes les valeurs des points échantillonnés. Comment ouvrir un fichier WAVE dans un programme [C] ?
Il nous faut créer une structure (WAVFILE dans notre programme) rigoureusement identique à celle de l’entête d’un fichier WAVE.
Charger le fichier dans le programme avec la commande « fopen ».
Dans le programme notre fichier audio est appelé WAV. On remarque aussi l’argument « rb » (read binary) dans la commande « fopen ». Le « b » est ajouté pour permettre au compilateur [C] de Windows de faire la distinction entre un fichier « TXT » et un fichier de données brutes. Lecture de l’entête et initialisation du Header par la commande « fread ».
« fread » est une fonction permettant la lecture de données brutes (binaires) d’un fichier dans un programme [C]. Il y a 4 paramètres à indiquer :
-La variable où les données seront enregistrées (tableau, structure ou variable simple)
-Taille des données à lire (en nombre d’octets)
-Nombre de fois que doit être effectuée la lecture
-Fichier à lire
Dans notre cas le programme va lire une fois le fichier WAV. Sa lecture se fera sur la taille du HEADER (correspondant à celle de l’entête) et les données lues seront enregistrées dans le HEADER. 
Le HEADER ainsi rempli contient toutes les caractéristiques de notre fichier WAVE, notamment la fréquence d’échantillonnage (header.frequency), le nombre de canaux (header.channels), le nombre d’octets par échantillon (header.bytes_by_capture), le nombre d’octets dans la partie DATA (header.bytes_in_data).
Les fichiers WAVE utilisés seront des mono (header.channels = 1).
On peut alors déterminer le nombre d’échantillons contenus dans la partie DATA (=header.bytes_in_data / header.bytes_by_capture).
Pour la suite de notre programme, « taille » correspondra à la puissance de 2 supérieure au nombre total d’échantillons du fichier WAVE lu.
Création d’un tableau dynamique qui contiendra les échantillons.
On utilisera un tableau de type malloc, car la taille du tableau ne pourra être déterminée qu’après exécution du programme.
Ce tableau est une matrice à 2 dimensions de 2 colonnes et « taille » lignes.
Il s’agit d’un tableau de nombres complexes, car nous verrons par la suite que l’algorithme de TF utilisé dans nos autres programmes d'analyse nécessite un tableau de cette forme. Enfin nous allons remplir ce tableau de nouveau avec la fonction « fread ».
Enfin ce tableau sera enregistré dans un fichier data

*/

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include "wave.h"
#include "ft.h"
#include "fft4g.h"
#include "fft8g.h"
#include "fftsg.h"
#include "fft4g_h.h"
#include "fft8g_h.h"
#include "fftsg_h.h"
#define SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr
#define pi 4*atan(1.0)

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
  /* La fonction suivante permet de remplacer '\n' par '\0' dans une chaine de caractere  */
  /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
void supp_saut_ligne ( char *chaine )
{
   char *c = NULL ;
   if( (c = strchr(chaine,'\n')) != NULL )
   {
      *c = '\0' ;
   }
   return ;
}


struct wavfile /*définit la structure de l entete d un wave*/
{
    char        id[4];          /*doit contenir "RIFF"*/
    int         totallength;        /*taille totale du fichier moins 8 bytes*/
    char        wavefmt[8];     /*doit etre "WAVEfmt "*/
    int         format;             /*16 pour le format PCM*/
    short       pcm;              /*1 for PCM format*/
    short       channels;         /*nombre de channels*/
    int         frequency;          /*frequence d echantillonage*/
    int         bytes_per_second;   /*nombre de bytes par secondes*/
    short       bytes_by_capture;   /*nombre de bytes par echantillon*/
    short       bits_per_sample;  /*nombre de bits par echantillon*/
    char        data[4];        /*doit contenir "data"*/
    int         bytes_in_data;      /*nombre de bytes de la partie data*/
};


/*void viderbuffer(FILE *stream);*/

int main(/*int argc, char *argv[]*/)
{


    int i=0;
    int k=0;
    signed long taille=1; /*variable qui correspondra par la suite a la longueur du tableau (
    puissance de 2)*/
    signed long taille2=0; /*variable qui correspondra par la suite a la longueur du tableau (
    puissance de 2)*/
    int nbech=0; /*nombre d echantillons extraits du fichier audio*/
    int puissance=0; /*variable qui serta incrémentée qui correspond a l indice de la puissance de 2 pour la taille du tableau*/
    char *filenam=NULL;
    char fichieraudio[100];
    char fichieraudio_out[100];
    float tempstotal=0;
    float filtre_freq, filtre_large;
    FILE *fic=NULL;

    /*---------------------selection du fichier audio-------------------------------*/
    printf ("entrer le nom du fichier audio a analyser :\n");
    scanf("%s", fichieraudio);
    printf ("nom du fichier : %s\n", fichieraudio);
    /*--------------fin de selection du fichier audio-------------------------------*/



    /*---------------------ouverture du wave----------------------------------------*/
    supp_saut_ligne ( fichieraudio ) ;
    /*filenam = malloc(100*sizeof(char));*/
    filenam=fichieraudio; 
    wave(filenam);
    FILE *wav = fopen(fichieraudio,"rb"); /*ouverture du fichier wave*/
    struct wavfile header; /*creation du header*/

    if ( wav == NULL )
    {
        printf("\nne peut pas ouvrir le fichier demande, verifier le nom\n");
        printf("ne pas oublier l'extention .wav\n");
        exit(1);
    }
    
    /*---------------------fin de ouverture du wave---------------------------------*/



    /*---------------------lecture de l entete et enregistrement dans header--------*/
    /*initialise le header par l'entete du fichier wave*/
    /*verifie que le fichier posséde un entete compatible*/
    if ( fread(&header,sizeof(header),1,wav) < 1 )
    {
        printf("\nne peut pas lire le header\n");
        exit(1);
    }
    if (    header.id[0] != 'R'|| header.id[1] != 'I'|| header.id[2] != 'F'|| header.id[3] != 'F' )
    {
        printf("\nerreur le fichier n'est pas un format wave valide\n");
        exit(1);/*TODO*/ /*si pas RIFF*/
    }
    if (header.channels==1)
    {
        printf("\nle fichier est mono\n");
        /*exit(1);*/
    }
    if (header.channels!=1)
    {
        printf("\nle fichier n'est pas mono\n");
        /*exit(1);*/
    }
    if (header.channels==2)
    {
        printf("\nle fichier est stéréo\n");
        /*exit(1);*/
    }
    else if (header.channels!=2)
    {
        printf("\nerreur : le fichier n'est pas stereo\n");
        exit(1);
    }
    /*----------------fin de lecture de l entete et enregistrement dans header-------*/
    
    /*-----------------Ouverture du fichier test.txt----*/
   	fic = fopen("test.txt", "w");
   	if (fic != NULL)
    {
       	printf("le fichier test.txt est ouvert");  	
    }
    else
    {
        printf("Erreur à l'ouverture du fichier test.txt\n");
       	return 1;
    }
	/*-----------------fin d'ouverture du fichier test.txt----*/
	

    /*-------------------------determiner la taille des tableaux---------------------*/
    
    nbech=(header.bytes_in_data/header.bytes_by_capture);
    fprintf (fic,"\nle fichier audio contient %d echantillons\n",nbech);
    while (nbech>taille)
    {
        taille=taille*2;
        taille2=taille2*2+1;
        puissance=puissance+1;
        /*printf("%ld %ld\n",taille2,taille);*/
        /*fprintf(fich,"%ld\n%ld\n",taille2,taille);*/
    }
    printf ("nombre de points traites : 2^%d=%ld\n",puissance,taille);
    tempstotal=(1./header.frequency)*taille;
    printf ("temps total : %f s\n",tempstotal);
    taille=taille*2;
    /*------------------fin de determiner la taille des tableaux---------------------*/


    /*taille=taille*2;*/
    
    /*---------------------creation des tableaux dynamiques--------------------------*/
    float *data=NULL; /*tableau de l'onde temporelle*/
    data=malloc( (taille) * sizeof(float));
    printf("cou\n");
    if (data == NULL)
    {
        exit(0);
    }

    double *filtre=NULL; /*tableau calculé par la transformée de fourrier*/
    filtre=malloc((taille) * sizeof(double));
    if (filtre == NULL)
    {
        exit(0);
    }


    /*---------------------fin de creation des tableaux dynamiques-------------------*/



    /*---------------------initialisation des tableaux dynamiques--------------------*/
    for(i=0; i<taille; i++)
    {
        data[i]=0;
        filtre[i]=0;
    }
    /*---------------------fin de initialisation des tableaux dynamiques-------------*/



    /*---------------------remplissage du tableau tab avec les echantillons----------*/
    i=0;
    short value=0;
    FILE *dat=fopen("onde.dat","w"); /*fichier data des echantillons*/
    FILE *dat1=fopen("onde1.dat","w"); /*fichier data contenant uniquement que les echantillons*/
    FILE *dat2=fopen("tf.dat","w");/*fichier.dat des fft*/
    FILE *dat3=fopen("tf_filtre.dat","w");/*fichier.dat du graph1d de pgplot*/
    while( fread(&value,(header.bits_per_sample)/8,2,wav) )
    {
        /*lecture des echantillons et enregistrement dans le tableau*/
        data[2*i]=value;
        fprintf(fic,"%d\n",value);
        i++;
    }
    printf("\nnombre d'echantillons lus : %d\n",i);
    printf("nombre de valeurs sauvegardees %d\n",i);
    k=0;
    for (k=0; k<i; k++)
    {
        fprintf(dat1,"%lf\n", data[2*k]);
/*permet de sauvegarder le tableau contenant que les données dans le fichier onde1.dat pour vérification manuelle des données*/
    }
    for (i=0; i<taille; i++)
    {
        fprintf(dat,"%lf\n", data[i]);
/*permet de sauvegarder le tableau dans le fichier onde.dat pour vérification manuelle des données*/
    }
    /*-----------------fin de remplissage du tableau avec les echantillons-----------*/



    /*---------------------fft-------------------------------------------------------*/
    four1(data,taille/2,1);
    /*---------------------fin de fft------------------------------------------------*/


 for(i=0; i<taille/2; i++)
    {
        fprintf (dat2,"%f %f\n",10*log10((data[2*i]/taille)*(data[2*i]/taille)),(2.*i*header.frequency/taille));
    }

    /*---------------------filtre----------------------------------------------------*/
    printf("frequence du filtre (Hz) ?");
    scanf("%f",&filtre_freq);
    printf("largeur du filtre ?");
    scanf("%f",&filtre_large);
    filtre_freq=(int)(filtre_freq*taille/header.frequency);
    filtre_large=(int)(filtre_large*taille/header.frequency);

/*    printf("%f %f",filtre_freq,filtre_large);*/

    for(i=0; i<taille; i++)
    {
        if(i>(filtre_freq-(filtre_large/2))&&i<(filtre_freq+(filtre_large/2)))
        {
            filtre[i]=0.5*(1-cos(2*pi*(i-(filtre_freq-(filtre_large/2)))/(filtre_large-1)));
        }
        else if (i>(taille-1-filtre_freq-(filtre_large/2))&&i<(taille-1-filtre_freq+(filtre_large/2)))
        {
            filtre[i]=0.5*(1-cos(2*pi*(i-(taille-1-filtre_freq-(filtre_large/2)))/(filtre_large-1)));
        }
        else
        {
            filtre[i]=0;
        }
    }

    for(i=0; i<taille/2; i++)
    {
        data[2*i]=filtre[2*i]*data[2*i];
        data[2*i+1]=filtre[2*i]*data[2*i+1];
    }
    for(i=0; i<taille; i++)
    {
        fprintf (dat3,"%f %f\n",data[i],(1.*i*header.frequency/taille));
    }
    /*--------------fin de filtre----------------------------------------------------*/

    /*---------------------fft inverse-----------------------------------------------*/
    four1(data,taille/2,-1);
    /*--------------fin de fft inverse-----------------------------------------------*/




    /*---------------------creation fichier wave-------------------------------------*/
    printf ("entrer le nom du fichier audio filtre pour l enregistrement :\n");
    scanf("%s", fichieraudio_out);
    printf ("nom du fichier : %s\n", fichieraudio_out);
    FILE *waveout = fopen(fichieraudio_out,"wb"); /*ouverture du fichier wave*/
    fwrite(&header,sizeof(header),1,waveout);
    for(i=0; i<nbech; i++)
    {
        value=/*fabs*/((data[2*i]*2)/taille); /*on peut noter la normalisation /taille de la tf inverse*/
        fwrite(&value,(header.bits_per_sample)/8,1,waveout);
    }
    /*---------------------fin de creation fichier wave------------------------------*/



    /*---------------------liberation de la memoire----------------------------------*/
    /*liberation de la ram des malloc*/

    free(data);
    data = NULL;
    free(filtre);
    filtre = NULL;
    fclose(wav);
    fclose(waveout);
    fclose(dat);
    fclose(dat1);
    fclose(dat2);
    fclose(dat3);
	fclose(fic);
	fic = NULL;
    /*---------------------fin de liberation de la memoire---------------------------*/



    return 0;
}
